.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "EVP_KDF_SCRYPT 7"
.TH EVP_KDF_SCRYPT 7 "2021-03-24" "1.1.1g" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
EVP_KDF_SCRYPT \- The scrypt EVP_KDF implementation
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Support for computing the \fBscrypt\fR password-based \s-1KDF\s0 through the \fB\s-1EVP_KDF\s0\fR
\&\s-1API.\s0
.PP
The \s-1EVP_KDF_SCRYPT\s0 algorithm implements the scrypt password-based key
derivation function, as described in \s-1RFC 7914.\s0  It is memory-hard in the sense
that it deliberately requires a significant amount of \s-1RAM\s0 for efficient
computation. The intention of this is to render brute forcing of passwords on
systems that lack large amounts of main memory (such as GPUs or ASICs)
computationally infeasible.
.PP
scrypt provides three work factors that can be customized: N, r and p. N, which
has to be a positive power of two, is the general work factor and scales \s-1CPU\s0
time in an approximately linear fashion. r is the block size of the internally
used hash function and p is the parallelization factor. Both r and p need to be
greater than zero. The amount of \s-1RAM\s0 that scrypt requires for its computation
is roughly (128 * N * r * p) bytes.
.PP
In the original paper of Colin Percival (\*(L"Stronger Key Derivation via
Sequential Memory-Hard Functions\*(R", 2009), the suggested values that give a
computation time of less than 5 seconds on a 2.5 GHz Intel Core 2 Duo are N =
2^20 = 1048576, r = 8, p = 1. Consequently, the required amount of memory for
this computation is roughly 1 GiB. On a more recent \s-1CPU\s0 (Intel i7\-5930K at 3.5
GHz), this computation takes about 3 seconds. When N, r or p are not specified,
they default to 1048576, 8, and 1, respectively. The maximum amount of \s-1RAM\s0 that
may be used by scrypt defaults to 1025 MiB.
.SS "Numeric identity"
.IX Subsection "Numeric identity"
\&\fB\s-1EVP_KDF_SCRYPT\s0\fR is the numeric identity for this implementation; it
can be used with the \fBEVP_KDF_CTX_new_id()\fR function.
.SS "Supported controls"
.IX Subsection "Supported controls"
The supported controls are:
.IP "\fB\s-1EVP_KDF_CTRL_SET_PASS\s0\fR" 4
.IX Item "EVP_KDF_CTRL_SET_PASS"
.PD 0
.IP "\fB\s-1EVP_KDF_CTRL_SET_SALT\s0\fR" 4
.IX Item "EVP_KDF_CTRL_SET_SALT"
.PD
These controls work as described in \*(L"\s-1CONTROLS\*(R"\s0 in \s-1\fBEVP_KDF_CTX\s0\fR\|(3).
.IP "\fB\s-1EVP_KDF_CTRL_SET_SCRYPT_N\s0\fR" 4
.IX Item "EVP_KDF_CTRL_SET_SCRYPT_N"
.PD 0
.IP "\fB\s-1EVP_KDF_CTRL_SET_SCRYPT_R\s0\fR" 4
.IX Item "EVP_KDF_CTRL_SET_SCRYPT_R"
.IP "\fB\s-1EVP_KDF_CTRL_SET_SCRYPT_P\s0\fR" 4
.IX Item "EVP_KDF_CTRL_SET_SCRYPT_P"
.PD
\&\fB\s-1EVP_KDF_CTRL_SET_SCRYPT_N\s0\fR expects one argument: \f(CW\*(C`uint64_t N\*(C'\fR
.Sp
\&\fB\s-1EVP_KDF_CTRL_SET_SCRYPT_R\s0\fR expects one argument: \f(CW\*(C`uint32_t r\*(C'\fR
.Sp
\&\fB\s-1EVP_KDF_CTRL_SET_SCRYPT_P\s0\fR expects one argument: \f(CW\*(C`uint32_t p\*(C'\fR
.Sp
These controls configure the scrypt work factors N, r and p.
.Sp
\&\fBEVP_KDF_ctrl_str()\fR type strings: \*(L"N\*(R", \*(L"r\*(R" and \*(L"p\*(R", respectively.
.Sp
The corresponding value strings are expected to be decimal numbers.
.SH "NOTES"
.IX Header "NOTES"
A context for scrypt can be obtained by calling:
.PP
.Vb 1
\& EVP_KDF_CTX *kctx = EVP_KDF_CTX_new_id(EVP_KDF_SCRYPT);
.Ve
.PP
The output length of an scrypt key derivation is specified via the
\&\fBkeylen\fR parameter to the \fBEVP_KDF_derive\fR\|(3) function.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
This example derives a 64\-byte long test vector using scrypt with the password
\&\*(L"password\*(R", salt \*(L"NaCl\*(R" and N = 1024, r = 8, p = 16.
.PP
.Vb 2
\& EVP_KDF_CTX *kctx;
\& unsigned char out[64];
\&
\& kctx = EVP_KDF_CTX_new_id(EVP_KDF_SCRYPT);
\&
\& if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_PASS, "password", (size_t)8) <= 0) {
\&     error("EVP_KDF_CTRL_SET_PASS");
\& }
\& if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SALT, "NaCl", (size_t)4) <= 0) {
\&     error("EVP_KDF_CTRL_SET_SALT");
\& }
\& if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SCRYPT_N, (uint64_t)1024) <= 0) {
\&     error("EVP_KDF_CTRL_SET_SCRYPT_N");
\& }
\& if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SCRYPT_R, (uint32_t)8) <= 0) {
\&     error("EVP_KDF_CTRL_SET_SCRYPT_R");
\& }
\& if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SCRYPT_P, (uint32_t)16) <= 0) {
\&     error("EVP_KDF_CTRL_SET_SCRYPT_P");
\& }
\& if (EVP_KDF_derive(kctx, out, sizeof(out)) <= 0) {
\&     error("EVP_KDF_derive");
\& }
\&
\& {
\&     const unsigned char expected[sizeof(out)] = {
\&         0xfd, 0xba, 0xbe, 0x1c, 0x9d, 0x34, 0x72, 0x00,
\&         0x78, 0x56, 0xe7, 0x19, 0x0d, 0x01, 0xe9, 0xfe,
\&         0x7c, 0x6a, 0xd7, 0xcb, 0xc8, 0x23, 0x78, 0x30,
\&         0xe7, 0x73, 0x76, 0x63, 0x4b, 0x37, 0x31, 0x62,
\&         0x2e, 0xaf, 0x30, 0xd9, 0x2e, 0x22, 0xa3, 0x88,
\&         0x6f, 0xf1, 0x09, 0x27, 0x9d, 0x98, 0x30, 0xda,
\&         0xc7, 0x27, 0xaf, 0xb9, 0x4a, 0x83, 0xee, 0x6d,
\&         0x83, 0x60, 0xcb, 0xdf, 0xa2, 0xcc, 0x06, 0x40
\&     };
\&
\&     assert(!memcmp(out, expected, sizeof(out)));
\& }
\&
\& EVP_KDF_CTX_free(kctx);
.Ve
.SH "CONFORMING TO"
.IX Header "CONFORMING TO"
\&\s-1RFC 7914\s0
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1EVP_KDF_CTX\s0,
\&\fBEVP_KDF_CTX_new_id\fR\|(3),
\&\fBEVP_KDF_CTX_free\fR\|(3),
\&\fBEVP_KDF_ctrl\fR\|(3),
\&\fBEVP_KDF_derive\fR\|(3),
\&\*(L"\s-1CONTROLS\*(R"\s0 in \s-1\fBEVP_KDF_CTX\s0\fR\|(3)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2017\-2018 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the OpenSSL license (the \*(L"License\*(R").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file \s-1LICENSE\s0 in the source distribution or at
<https://www.openssl.org/source/license.html>.
